---
title: "How to use Hydra in Machine Learning projects"
description: "Complete tutorial on using Hydra in your machine learning projects. Everything in hydra is discussed with a dummy example (except structured configs)."
layout: post
toc: true
comments: true
hide: false
search_exclude: true
categories: [general]
---

[code for blog post](https://github.com/KushajveerSingh/hydra_ml_example), [hydra website](https://hydra.cc/)

In an effort to increase standardization across the PyTorch ecosystem Facebook AI in a recent [blog post](https://ai.facebook.com/blog/reengineering-facebook-ais-deep-learning-platforms-for-interoperability/) told that they would be leveraging Facebook's open source [Hydra framework](https://hydra.cc/) to handle configs, and also offer an integration with [PyTorch Lightning](https://www.pytorchlightning.ai/). This post is about Hydra.

If you are reading this post then I assume that you are familiar with what are config files, why are they useful and how they increase reproducibility. And you also know what nightmare is [argparse](https://docs.python.org/3/library/argparse.html). In general, with config files you can pass all the hyperparameters, you can define all the global constants, define dataset splits and ... without touching the core code of your project.

On [Hydra website](https://hydra.cc/docs/intro) the following are listed as the key features of Hydra
* Hierarchical configuration composable from multiple sources
* Configuration can be specified or overridden from the command line
* Dynamic command line tab completion
* Run your application locally or launch it to run remotely
* Run multiple jobs with different arguments with a single command

For the rest of the post, I will introduce Hydra features one-by-one with an example of use case. So follow along, it would be a fun ride.

## Understanding Hydra setup process
Install Hydra (I am using version `1.0`)
```
pip install hydra-core --upgrade
```

When working on a project your general repository structure would look something like this
```bash
src
├── config
│   └── config.yaml
└── main.py
```

Let's start with a simple example that will show you the main syntax of using Hydra,
```yaml
### config.yaml

batch_size: 10
lr: 1e-4
```

And the corresponding `main.py` file
```python
### main.py

import hydra
from omegaconf import DictConfig, OmegaConf

@hydra.main(config_name="config/config.yaml")
def main_func(cfg: DictConfig):
    working_dir = os.getcwd()
    print(f"The current working directory is {working_dir}\n")

    print("The contents of the config file are")
    print(OmegaConf.to_yaml(cfg))

    # To access elements of the config
    print(f"The batch size is {cfg.batch_size}")
    print(f"The learning rate is {cfg['lr']}")

if __name__ == "__main__":
    main_func()
```

Now when I run `python main.py` I get the following output
```bash
The current working directory is src/outputs/2021-03-13/16-22-21

The contents of the config file are
batch_size: 10
lr: 0.0001

The batch size is 10
The learning rate is 0.0001
```

> **Note**: The path is shortened to not include the complete path from root. For the rest of the post, assume we are working in `src` directory.

A lot happened, let's parse it one by one
* `omegaconf` is installed by default when you install `hydra`. It is only used to provide the type annotation for `cfg` argument in `main_func`. If you want to print the contents of `cfg` then you can use `OmegaConf`. Apart from this `omegaconf` does not have any important role.

* `@hydra.main(config_name="config/config.yaml")` This is the main decorator function that you will use, whenever you want to use any configuration file from the `config` folder. An alternative way to write this command is `@hydra.main(config_path="config", config_name="config.yaml")`.

* **Current working directory is changed**. This is the most important point when using Hydra. An explanation follows below.

### How hydra handles different runs
In short, whenever you execute your program using `python main.py` Hydra will create a new folder in `outputs` directory with the following naming scheme `outputs/YYYY-MM-DD/HH-mm-SS` i.e. the data and time at which the file was executed. Think about this for a second. Hydra provides you a way to maintain the logs of every run without you having to worry about it. In my case the directory structure looks like after running `python main.py` (Let's not worry about the contents of each folder for now).
```bash
src
├── config
│   └── config.yaml
├── main.py
├── outputs
│   └── 2021-03-13
│       └── 17-14-24
│           ├── .hydra
│           │   ├── config.yaml
│           │   ├── hydra.yaml
│           │   └── overrides.yaml
│           ├── main.log
```

What happens actually? When you run `src/main.py`, hydra moves this file to `src/outputs/2021-03-13/16-22-21/main.py` and then runs it. You can verify this by checking the output of `os.getcwd()` as shown in the above example. This means if your `main.py` relied on some external file, say `test.txt`, then you would have to use `../../../test.txt` instead, as you are no longer running the program in `src` directory. This also means that everything you save to disk would be saved relative to `src/outputs/2021-03-13/16-22-21/`. 

Hydra provides two utility functions to handle this situation 
* **hydra.utils.get_original_cwd()**: Get the original current working directory
    
    ```python
    orig_cwd = hydra.utils.get_original_cwd()
    path = f"{orig_cwd}/test.txt"

    # path = src/test.txt
    ```
* **hydra.utils.to_absolute_path(file_name)**:

    ```python
    path = hydra.utils.to_absolute_path('test.txt')

    # path = src/test.txt
    ```

Let's recap this using a short example. Let's say we want to read `src/test.txt` and write the output to `output.txt`.
```python
@hydra.main(config_name="config/config.yaml")
def main_func(cfg: DictConfig):
    orig_cwd = hydra.utils.get_original_cwd()

    # Read file
    path = f"{orig_cwd}/test.txt"
    with open(path, "r") as f:
        print(f.read())

    # Write file
    path = f"output.txt"
    with open(path, "w") as f:
        f.write("This is a dog")
```

We can check the directory structure again
```bash
src
├── config
│   └── config.yaml
├── main.py
├── outputs
│   └── 2021-03-13
│       └── 17-14-24
│           ├── .hydra
│           │   ├── config.yaml
│           │   ├── hydra.yaml
│           │   └── overrides.yaml
│           ├── main.log
│           └── output.txt
└── test.txt
```

The file was written to the folder created by hydra. This is a good way to save intermediate results when you are developing something. You can save the accuracy results of your model when using different learning rates using this. 

The main point is use `orig_cwd = hydra.utils.get_original_cwd()` to get the original working directory path and then you do not have to worry about hydra running your code in different folder.

### Contents of each subfolder
Each subfolder has the following substructure
```bash
src/outputs/2021-03-13/17-14-24/
├── .hydra
│   ├── config.yaml
│   ├── hydra.yaml
│   └── overrides.yaml
├── main.log
```

* `config.yaml` - Copy of the config file passed to the function (It dosen't matter if you pass `foo.yaml`, this file would still be named `config.yaml`)
* `hydra.yaml` - Copy of the hydra config file. We will see how we can change some of the defaults used by hydra. (You can specify the message of `python main.py --help` here)
* `overrides.yaml` - Copy of any argument that you provide through command line and which changes one of the default value would be stored here
* `main.log` - Output of logger would be stored here. (For `foo.py` this file would be named `foo.log`)

### How to use logging
With Hydra you can easily use the [logging](https://docs.python.org/3/library/logging.html) package provided by Python in your code without any setup. The output of the log is stored in `main.log`. Usage example is shown below
```python
import logging

log = logging.getLogger(__name__)

@hydra.main(config_name="config/config.yaml")
def main_func(cfg: DictConfig):
    log.debug("Debug level message")
    log.info("Info level message")
    log.warning("Warning level message")
```

The log of `python main.py` in this case would be (in `main.log`)
```python
[2021-03-13 17:36:06,493][__main__][INFO] - Info level message
[2021-03-13 17:36:06,493][__main__][WARNING] - Warning level message
```

If you want to include `DEBUG` also, then override `hydra.verbose=true` or `hydra.verbose=__main__`. The output in `main.log` in this case would be
```python
[2021-03-13 17:36:38,425][__main__][DEBUG] - Debug level message
[2021-03-13 17:36:38,425][__main__][INFO] - Info level message
[2021-03-13 17:36:38,425][__main__][WARNING] - Warning level message
```

## Quick OmegaConf overview
[OmegaCong](https://omegaconf.readthedocs.io/en/latest/index.html) is a YAML based hierarchical configuration system, with support for merging configurations from multiple sources (files, CLI argument, environment variables). You just need to know YAML to use Hydra. OmegaConf is used by Hydra in the background to handle everything for you.

The main things you need to know are shown in the config file below
```yaml
server:
  ip: "127.0.0.1"
  port: ???       # Missing value. Must be provided at command line
  address: "${server.ip}:${server.port}" # String interpolation
```

Now in `main.py` you can access the server address as follows
```python
@hydra.main(config_name="config/config.yaml")
def main_func(cfg: DictConfig):
    print(f"The server address = {cfg.server.address}")


# python main.py server.port=10
# The server address = 127.0.0.1:10
```

This syntax `address:${server.ip}` is very useful and we will later see use cases of this.

## Using Hydra for ML projects
Now you know the basic working of hydra, we can focus on using Hydra to develop a machine learning project. Go through the hydra [documentation](https://hydra.cc/docs/intro) after this post as there are some minor things that I am left and I do not discuss *Structured Configs* (alternate to yaml files).

The `src` directory of the project has the following structure
```bash
src
├── config
│   └── config.yaml
└── main.py
```

Now let's get started.

### Dataset